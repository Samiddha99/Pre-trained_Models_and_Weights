

#include <iostream>
#include <dlib/dnn.h>
#include <dlib/data_io.h>
#include <dlib/dir_nav.h>
#include <dlib/gui_widgets.h>
#include <dlib/console_progress_indicator.h>
#include <dlib/time_this.h>

using namespace std;
using namespace dlib;





// reference net from public dlib car detector
template <long num_filters, typename SUBNET> using con5d = con<num_filters,5,5,2,2,SUBNET>;
template <long num_filters, typename SUBNET> using con5  = con<num_filters,5,5,1,1,SUBNET>;
template <typename SUBNET> using downsampler  = relu<bn_con<con5d<32, relu<bn_con<con5d<32, relu<bn_con<con5d<16,SUBNET>>>>>>>>>;
template <typename SUBNET> using rcon5  = relu<bn_con<con5<55,SUBNET>>>;
using net_type = loss_mmod<con<1,9,9,1,1,rcon5<rcon5<rcon5<downsampler<input_rgb_image_pyramid<pyramid_down<6>>>>>>>>;


// ----------------------------------------------------------------------------------------

int ignore_overlapped_boxes(
    std::vector<mmod_rect>& boxes,
    const test_box_overlap& overlaps
)
/*!
    ensures
        - Whenever two rectangles in boxes overlap, according to overlaps(), we set the
          smallest box to ignore.
        - returns the number of newly ignored boxes.
!*/
{
    int num_ignored = 0;
    for (size_t i = 0; i < boxes.size(); ++i)
    {
        if (boxes[i].ignore)
            continue;
        for (size_t j = i+1; j < boxes.size(); ++j)
        {
            if (boxes[j].ignore)
                continue;
            if (overlaps(boxes[i], boxes[j]))
            {
                ++num_ignored;
                if(boxes[i].rect.area() < boxes[j].rect.area())
                    boxes[i].ignore = true;
                else
                    boxes[j].ignore = true;
            }
        }
    }
    return num_ignored;
}

// ----------------------------------------------------------------------------------------

void find_cars(int argc, char** argv)
{
    //image_window win;
    net_type net;
    shape_predictor sp;


    // Generated by training on just the kitti_train.xml file that contains the entire
    // kitti car dataset.  The convert_to_xml.cpp file was used to convert the kitti
    // training metadata into dlib's .xml format and output the kitti_train.xml.
    deserialize("kitti_Cars_NOtesting_fullKittiTrainDataset_100x42detWin_IoU0.6.dat") >> net;
    // trained with kitti_train_box_regression.cpp
    deserialize("sp_kitti_1511300994.dat") >> sp;
    

    create_directory("kitti_dets");

    console_progress_indicator pbar(argc);
    for (int i = 1; i < argc; ++i)
    {
        pbar.print_status(i);
        matrix<rgb_pixel> img;
        load_image(img, argv[i]);
        pyramid_up(img);
        pyramid_up(img);

        pyramid_down<2> pyr;

        std::vector<mmod_rect> dets;
        dets = net.process(img,-1.03);
        //win.clear_overlay();
        //win.set_image(img);

        string filename = "kitti_dets/" + left_substr(file(string(argv[i])).name(),".") + ".txt";
        ofstream fout(filename);
        if (!fout)
            cout << "can't open " << filename << endl;

        // Run the detector on the image and show us the output.
        for (auto&& d : dets) 
        {
            full_object_detection shape;
            shape = sp(img, d.rect);
            rectangle rect;
            for (size_t i = 0; i < shape.num_parts(); ++i)
                rect += shape.part(i);

            /*
            if (d.label == "Car")
                win.add_overlay(rect, rgb_pixel(255,0,0), d.label);
            else 
                win.add_overlay(rect, rgb_pixel(255,255,0), d.label);
            */

            rect = pyr.rect_down(rect,2);
            fout << "Car -1 -1 0.00 " << rect.left() << " " << rect.top() << " " << rect.right() << " " << rect.bottom() << " -1 -1 -1 -1000 -1000 -1000 -10 " << d.detection_confidence << endl;
        }
    }
    exit(0);
}



int main(int argc, char** argv) try
{
    find_cars(argc, argv);

    if (argc != 2)
    {
        cout << "Give path to a folder containing training xml files." << endl;
        cout << endl;
        return 0;
    }
    const std::string data_directory = argv[1];


    std::vector<matrix<rgb_pixel>> images_train, images_test;
    std::vector<std::vector<mmod_rect>> boxes_train, boxes_test;
    load_image_dataset(images_train, boxes_train, image_dataset_file(data_directory+"/kitti_train.xml").boxes_match_label("Car").boxes_match_label("DontCare").skip_empty_images());
    //load_image_dataset(images_test, boxes_test, image_dataset_file(data_directory+"/kitti_train_test.xml").boxes_match_label("Car").boxes_match_label("DontCare").skip_empty_images());


    int num_overlapped_ignored_test = 0;
    for (auto& v : boxes_test)
        num_overlapped_ignored_test += ignore_overlapped_boxes(v, test_box_overlap(0.50, 0.94));

    int num_overlapped_ignored = 0;
    int num_additional_ignored = 0;
    for (auto& v : boxes_train)
    {
        num_overlapped_ignored += ignore_overlapped_boxes(v, test_box_overlap(0.50, 0.94));
    }

    cout << "num_overlapped_ignored: "<< num_overlapped_ignored << endl;
    cout << "num_additional_ignored: "<< num_additional_ignored << endl;
    cout << "num_overlapped_ignored_test: "<< num_overlapped_ignored_test << endl;


    cout << "num training images: " << images_train.size() << endl;
    cout << "num testing images: " << images_test.size() << endl;


    mmod_options options(boxes_train, 100, 42);


    options.overlaps_ignore = test_box_overlap(0.5, 0.95);
    options.truth_match_iou_threshold = 0.6;

    net_type net(options);

    net.subnet().layer_details().set_num_filters(options.detector_windows.size());


    dnn_trainer<net_type> trainer(net,sgd(0.00004,0.9));
    trainer.set_learning_rate(0.1);
    trainer.be_verbose();


    trainer.set_iterations_without_progress_threshold(15000);
    trainer.set_test_iterations_without_progress_threshold(1000);

    const string sync_filename = "kitti_Cars_NOtesting_fullKittiTrainDataset_100x42detWin_IoU0.6";
    trainer.set_synchronization_file("sync_"+sync_filename, std::chrono::minutes(5));

    trainer.set_test_iterations_without_progress_threshold(2000);



    std::vector<matrix<rgb_pixel>> mini_batch_samples;
    std::vector<std::vector<mmod_rect>> mini_batch_labels; 
    random_cropper cropper;
    cropper.set_seed(time(0));
    cropper.set_chip_dims(350, 350);
    cropper.set_min_object_size(97,40); 
    cropper.set_max_rotation_degrees(2);
    dlib::rand rnd;

    // Log the training parameters to the console
    cout << trainer << cropper << endl;

    int cnt = 1;
    // Run the trainer until the learning rate gets small.  
    while(trainer.get_learning_rate() >= 1e-4)
    {
        // Every 30 mini-batches we do a testing mini-batch.  
        if (cnt%30 != 0 || images_test.size() == 0 || true)
        {
            cropper(64, images_train, boxes_train, mini_batch_samples, mini_batch_labels);
            for (auto&& img : mini_batch_samples)
                disturb_colors(img, rnd);

            trainer.train_one_step(mini_batch_samples, mini_batch_labels);
        }
        else
        {
            cropper(64, images_test, boxes_test, mini_batch_samples, mini_batch_labels);
            for (auto&& img : mini_batch_samples)
                disturb_colors(img, rnd);

            trainer.test_one_step(mini_batch_samples, mini_batch_labels);
        }
        ++cnt;
    }
    // wait for training threads to stop
    trainer.get_net();
    cout << "done training" << endl;

    // Save the network to disk
    net.clean();
    serialize(sync_filename + ".dat") << net;


    cout << trainer << cropper << endl;

    cout << "\nsync_filename: " << sync_filename << endl;
    cout << "num training images: "<< images_train.size() << endl;
    //cout << "training results: " << test_object_detection_function(net, images_train, boxes_train, test_box_overlap(), 0, options.overlaps_ignore);

    cout << "training upsampled results 0.7overlap: " << test_object_detection_function(net, images_train, boxes_train, test_box_overlap(0.7), -1.03, options.overlaps_ignore);
    cout << "training upsampled results 0.4overlap: " << test_object_detection_function(net, images_train, boxes_train, test_box_overlap(0.4), -1.03, options.overlaps_ignore);


    cout << "num testing images: "<< images_test.size() << endl;


    // Now we run the detector on the images and save the results.  These results are saved
    // to files which can be loaded by kitti_train_box_regression.cpp to train the
    // shape_predictor that does bounding box regression.  Once you have the
    // shape_predictor you can use it to run the find_cars() function above.

    std::vector<std::vector<mmod_rect>> all_mmod_dets;

    //image_window win;
    pyramid_down<2> pyr;
    console_progress_indicator pbar(images_test.size());
    for (size_t i = 0; i < images_test.size(); ++i)
    {
        pbar.print_status(i);
        int times = 0;
        auto img = images_test[i];
        //while (img.size() < 1800*1800)
        {
            pyramid_up(img);
            ++times;
            pyramid_up(img);
            ++times;
        }

        //auto dets = net.process(img, -0.8);
        auto dets = net(img);

        for (auto&& d : dets)
            d.rect = pyr.rect_down(d.rect, times);

        all_mmod_dets.push_back(dets);


        //cout << "hit enter to continue..." << endl;
        //cin.get();
    }
    serialize("all_mmod_dets_test_"+sync_filename+".dat") << all_mmod_dets;


    all_mmod_dets.clear();
    pbar = console_progress_indicator(images_train.size());
    for (size_t i = 0; i < images_train.size(); ++i)
    {
        pbar.print_status(i);
        int times = 0;
        auto img = images_train[i];
        //while (img.size() < 1800*1800)
        {
            pyramid_up(img);
            ++times;
            pyramid_up(img);
            ++times;
        }

        //auto dets = net.process(img, -0.8);
        auto dets = net(img);

        for (auto&& d : dets)
            d.rect = pyr.rect_down(d.rect, times);

        all_mmod_dets.push_back(dets);


        //cout << "hit enter to continue..." << endl;
        //cin.get();
    }
    serialize("all_mmod_dets_train_"+sync_filename+".dat") << all_mmod_dets;

    return 0;

}
catch(std::exception& e)
{
    cout << e.what() << endl;
}




